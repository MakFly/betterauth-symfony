<?php

declare(strict_types=1);

namespace App\Controller\Api;

use App\Controller\Api\Trait\ApiResponseTrait;
use BetterAuth\Core\Entities\User;
use BetterAuth\Providers\AccountLinkProvider\AccountLinkProvider;
use BetterAuth\Providers\OAuthProvider\OAuthManager;
use BetterAuth\Symfony\Security\Attribute\CurrentUser;
use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Attribute\Route;

/**
 * Account Link Controller.
 *
 * Handles linking/unlinking third-party accounts (OAuth providers) to user accounts.
 * Generated by BetterAuth - customize as needed.
 */
#[Route('/auth/account', name: 'api_auth_account_')]
class AccountLinkController extends AbstractController
{
    use ApiResponseTrait;

    public function __construct(
        private readonly AccountLinkProvider $accountLinkProvider,
        private readonly OAuthManager $oauthManager,
        private readonly ?LoggerInterface $logger = null,
    ) {
    }

    /**
     * List linked accounts for current user.
     *
     * GET /auth/account/links
     * Header: Authorization: Bearer <token>
     */
    #[Route('/links', name: 'list', methods: ['GET'])]
    public function list(#[CurrentUser] User $user): JsonResponse
    {
        try {
            $linkedAccounts = $this->accountLinkProvider->getLinkedAccounts($user->getId());

            $accounts = array_map(fn($account) => [
                'id' => $account->getId(),
                'provider' => $account->getProvider(),
                'providerId' => $account->getProviderId(),
                'email' => $account->getProviderEmail(),
                'name' => $account->getProviderName(),
                'linkedAt' => $account->getCreatedAt()?->format('c'),
            ], $linkedAccounts);

            return $this->json([
                'success' => true,
                'data' => [
                    'accounts' => $accounts,
                    'count' => count($accounts),
                ],
                'meta' => ['timestamp' => date('c'), 'version' => 'v1'],
            ]);
        } catch (\Exception $e) {
            $this->logger?->error('Failed to list linked accounts', [
                'userId' => $user->getId(),
                'error' => $e->getMessage(),
            ]);

            return $this->json(
                $this->formatErrorResponse('list_failed', 'Failed to retrieve linked accounts', 500),
                500
            );
        }
    }

    /**
     * Initiate linking a new account.
     *
     * GET /auth/account/link/{provider}
     * Header: Authorization: Bearer <token>
     * Query: ?redirect=true (optional)
     */
    #[Route('/link/{provider}', name: 'link_init', methods: ['GET'])]
    public function linkInit(string $provider, #[CurrentUser] User $user, Request $request): JsonResponse|RedirectResponse
    {
        $supportedProviders = ['google', 'github', 'facebook', 'microsoft', 'discord', 'apple', 'twitter'];

        if (!in_array($provider, $supportedProviders, true)) {
            return $this->json(
                $this->formatErrorResponse('invalid_provider', 'Unsupported provider: ' . $provider, 400),
                400
            );
        }

        try {
            // Check if already linked
            $existing = $this->accountLinkProvider->getLinkedAccount($user->getId(), $provider);
            if ($existing) {
                return $this->json(
                    $this->formatErrorResponse('already_linked', 'Account is already linked to ' . $provider, 409),
                    409
                );
            }

            $state = bin2hex(random_bytes(16));
            $authUrl = $this->oauthManager->getAuthorizationUrl($provider, $state);

            // Store linking context
            $request->getSession()->set('account_link_state', $state);
            $request->getSession()->set('account_link_provider', $provider);
            $request->getSession()->set('account_link_user_id', $user->getId());

            if ($request->query->getBoolean('redirect')) {
                return new RedirectResponse($authUrl);
            }

            return $this->json([
                'success' => true,
                'data' => [
                    'provider' => $provider,
                    'authorizationUrl' => $authUrl,
                    'state' => $state,
                ],
                'meta' => ['timestamp' => date('c'), 'version' => 'v1'],
            ]);
        } catch (\Exception $e) {
            $this->logger?->error('Failed to initiate account linking', [
                'userId' => $user->getId(),
                'provider' => $provider,
                'error' => $e->getMessage(),
            ]);

            return $this->json(
                $this->formatErrorResponse('link_init_failed', 'Failed to initiate account linking', 500),
                500
            );
        }
    }

    /**
     * Handle account linking callback.
     *
     * GET /auth/account/link/{provider}/callback
     */
    #[Route('/link/{provider}/callback', name: 'link_callback', methods: ['GET'])]
    public function linkCallback(string $provider, Request $request): JsonResponse
    {
        $code = $request->query->get('code');
        $state = $request->query->get('state');
        $error = $request->query->get('error');

        if ($error) {
            return $this->json(
                $this->formatErrorResponse('oauth_denied', 'Account linking was denied', 400),
                400
            );
        }

        if (!$code) {
            return $this->json(
                $this->formatErrorResponse('missing_code', 'Authorization code is required', 400),
                400
            );
        }

        // Verify state
        $storedState = $request->getSession()->get('account_link_state');
        $storedProvider = $request->getSession()->get('account_link_provider');
        $userId = $request->getSession()->get('account_link_user_id');

        if (!$storedState || $storedState !== $state || $storedProvider !== $provider || !$userId) {
            return $this->json(
                $this->formatErrorResponse('invalid_state', 'Invalid linking state', 400),
                400
            );
        }

        try {
            // Exchange code for tokens
            $oauthUser = $this->oauthManager->getUserFromCode($provider, $code);

            // Link account
            $this->accountLinkProvider->linkAccount($userId, [
                'provider' => $provider,
                'provider_id' => $oauthUser['id'],
                'provider_email' => $oauthUser['email'] ?? null,
                'provider_name' => $oauthUser['name'] ?? null,
                'access_token' => $oauthUser['access_token'] ?? null,
                'refresh_token' => $oauthUser['refresh_token'] ?? null,
            ]);

            // Clear session data
            $request->getSession()->remove('account_link_state');
            $request->getSession()->remove('account_link_provider');
            $request->getSession()->remove('account_link_user_id');

            $this->logger?->info('Account linked successfully', [
                'userId' => $userId,
                'provider' => $provider,
            ]);

            return $this->json($this->formatSuccessResponse(
                'Account linked successfully',
                ['provider' => $provider, 'linked' => true]
            ));
        } catch (\Exception $e) {
            $this->logger?->error('Account linking failed', [
                'userId' => $userId,
                'provider' => $provider,
                'error' => $e->getMessage(),
            ]);

            return $this->json(
                $this->formatErrorResponse('link_failed', $e->getMessage(), 400),
                400
            );
        }
    }

    /**
     * Unlink an account.
     *
     * DELETE /auth/account/link/{provider}
     * Header: Authorization: Bearer <token>
     */
    #[Route('/link/{provider}', name: 'unlink', methods: ['DELETE'])]
    public function unlink(string $provider, #[CurrentUser] User $user): JsonResponse
    {
        try {
            // Check if account is linked
            $linked = $this->accountLinkProvider->getLinkedAccount($user->getId(), $provider);
            if (!$linked) {
                return $this->json(
                    $this->formatErrorResponse('not_linked', 'Account is not linked to ' . $provider, 404),
                    404
                );
            }

            // Check if this is the only auth method
            $allLinks = $this->accountLinkProvider->getLinkedAccounts($user->getId());
            $hasPassword = $user->getPassword() !== null;

            if (count($allLinks) === 1 && !$hasPassword) {
                return $this->json(
                    $this->formatErrorResponse(
                        'cannot_unlink',
                        'Cannot unlink the only authentication method. Set a password first.',
                        400
                    ),
                    400
                );
            }

            $this->accountLinkProvider->unlinkAccount($user->getId(), $provider);

            $this->logger?->info('Account unlinked', [
                'userId' => $user->getId(),
                'provider' => $provider,
            ]);

            return $this->json($this->formatSuccessResponse(
                'Account unlinked successfully',
                ['provider' => $provider, 'unlinked' => true]
            ));
        } catch (\Exception $e) {
            $this->logger?->error('Account unlinking failed', [
                'userId' => $user->getId(),
                'provider' => $provider,
                'error' => $e->getMessage(),
            ]);

            return $this->json(
                $this->formatErrorResponse('unlink_failed', 'Failed to unlink account', 500),
                500
            );
        }
    }
}

