<?php

declare(strict_types=1);

namespace App\Controller;

use App\Controller\Trait\ApiResponseTrait;
use BetterAuth\Providers\MagicLinkProvider\MagicLinkProvider;
use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\DependencyInjection\Attribute\Autowire;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Attribute\Route;

/**
 * Magic Link Controller.
 *
 * Handles passwordless authentication via magic links.
 * Generated by BetterAuth - customize as needed.
 */
#[Route('/auth/magic-link', name: 'api_auth_magic_link_')]
class MagicLinkController extends AbstractController
{
    use ApiResponseTrait;

    public function __construct(
        private readonly MagicLinkProvider $magicLinkProvider,
        private readonly ?LoggerInterface $logger = null,
        #[Autowire(env: 'FRONTEND_URL')]
        private readonly string $frontendUrl = 'http://localhost:3000',
    ) {
    }

    /**
     * Request a magic link.
     *
     * POST /auth/magic-link/request
     * Body: { "email": "..." }
     */
    #[Route('/request', name: 'request', methods: ['POST'])]
    public function request(Request $request): JsonResponse
    {
        $data = $request->toArray();

        if (empty($data['email'])) {
            return $this->json(
                $this->formatErrorResponse('validation_error', 'Email is required', 422),
                422
            );
        }

        if (!filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
            return $this->json(
                $this->formatErrorResponse('validation_error', 'Invalid email format', 422),
                422
            );
        }

        $callbackUrl = $data['callbackUrl'] ?? rtrim($this->frontendUrl, '/') . '/auth/magic-link';

        try {
            $this->magicLinkProvider->sendMagicLink(
                $data['email'],
                $request->getClientIp() ?? '127.0.0.1',
                $request->headers->get('User-Agent') ?? 'Unknown',
                $callbackUrl
            );

            $this->logger?->info('Magic link sent', ['email' => $data['email']]);

            // Always return success to prevent email enumeration
            return $this->json($this->formatSuccessResponse(
                'If an account exists with this email, a magic link has been sent',
                ['emailSent' => true]
            ));
        } catch (\Exception $e) {
            $this->logger?->warning('Magic link request failed', [
                'email' => $data['email'],
                'error' => $e->getMessage(),
            ]);

            // Still return success to prevent enumeration
            return $this->json($this->formatSuccessResponse(
                'If an account exists with this email, a magic link has been sent',
                ['emailSent' => true]
            ));
        }
    }

    /**
     * Verify magic link and authenticate.
     *
     * POST /auth/magic-link/verify
     * Body: { "token": "..." }
     */
    #[Route('/verify', name: 'verify', methods: ['POST'])]
    public function verify(Request $request): JsonResponse
    {
        $data = $request->toArray();

        if (empty($data['token'])) {
            return $this->json(
                $this->formatErrorResponse('validation_error', 'Token is required', 422),
                422
            );
        }

        try {
            $result = $this->magicLinkProvider->verifyMagicLink(
                $data['token'],
                $request->getClientIp() ?? '127.0.0.1',
                $request->headers->get('User-Agent') ?? 'Unknown'
            );

            if (!$result['success'] || !isset($result['user'])) {
                return $this->json(
                    $this->formatErrorResponse('invalid_token', $result['error'] ?? 'Invalid or expired magic link', 401),
                    401
                );
            }

            $this->logger?->info('Magic link authentication successful', [
                'userId' => $result['user']['id'],
                'email' => $result['user']['email'],
            ]);

            return $this->json([
                'success' => true,
                'data' => [
                    'auth' => [
                        'accessToken' => $result['access_token'],
                        'refreshToken' => $result['refresh_token'],
                        'tokenType' => $result['token_type'] ?? 'Bearer',
                        'expiresIn' => $result['expires_in'] ?? 3600,
                        'expiresAt' => date('c', time() + ($result['expires_in'] ?? 3600)),
                    ],
                    'user' => $result['user'],
                    'authMethod' => 'magic_link',
                ],
                'meta' => ['timestamp' => date('c'), 'version' => 'v1'],
            ]);
        } catch (\Exception $e) {
            $this->logger?->warning('Magic link verification failed', [
                'error' => $e->getMessage(),
            ]);

            return $this->json(
                $this->formatErrorResponse('invalid_token', 'Invalid or expired magic link', 401),
                401
            );
        }
    }

    /**
     * Check if magic link is valid (without consuming it).
     *
     * POST /auth/magic-link/check
     * Body: { "token": "..." }
     */
    #[Route('/check', name: 'check', methods: ['POST'])]
    public function check(Request $request): JsonResponse
    {
        $data = $request->toArray();

        if (empty($data['token'])) {
            return $this->json(
                $this->formatErrorResponse('validation_error', 'Token is required', 422),
                422
            );
        }

        try {
            $result = $this->magicLinkProvider->checkToken($data['token']);

            return $this->json([
                'success' => true,
                'data' => [
                    'valid' => $result['valid'] ?? false,
                    'email' => $result['email'] ?? null,
                    'expiresAt' => isset($result['expires_at']) ? date('c', $result['expires_at']) : null,
                ],
                'meta' => ['timestamp' => date('c'), 'version' => 'v1'],
            ]);
        } catch (\Exception $e) {
            return $this->json([
                'success' => true,
                'data' => ['valid' => false],
                'meta' => ['timestamp' => date('c'), 'version' => 'v1'],
            ]);
        }
    }
}

